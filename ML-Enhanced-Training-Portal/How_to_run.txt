python -m streamlit run adaptive_test.py
**/import streamlit as st
import json
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model
import pandas as pd
import os
import time
from datetime import datetime

# ‚úÖ Load AI Model Safely
try:
    model_path = "../model/dqn_adaptive_learning_model.h5"
    custom_objects = {"MeanSquaredError": tf.keras.losses.MeanSquaredError()}
    model = load_model(model_path, custom_objects=custom_objects)
except Exception as e:
    st.error(f"‚ö†Ô∏è Error loading the model: {str(e)}")
    model = None

# ‚úÖ Load Questions from JSON
try:
    questions_path = os.path.join("..", "data", "questions.json")
    with open(questions_path, "r") as f:
        questions_data = json.load(f)
except Exception as e:
    st.error(f"‚ö†Ô∏è Error loading questions.json: {str(e)}")
    questions_data = {}

# ‚úÖ Define Module Encoding
module_map = {"Easy": 0, "Medium": 1, "Hard": 2}
reverse_module_map = {0: "Easy", 1: "Medium", 2: "Hard"}

# ‚úÖ Initialize Session State Variables
if "selected_domain" not in st.session_state:
    st.session_state.selected_domain = None
if "test_history" not in st.session_state:
    st.session_state.test_history = []
if "current_question" not in st.session_state:
    st.session_state.current_question = 0
if "user_answers" not in st.session_state:
    st.session_state.user_answers = {}
if "domain_module_progress" not in st.session_state:
    st.session_state.domain_module_progress = {}
if "test_in_progress" not in st.session_state:
    st.session_state.test_in_progress = False
if "show_results" not in st.session_state:
    st.session_state.show_results = False
if "start_time" not in st.session_state:
    st.session_state.start_time = None
if "student_id" not in st.session_state:
    st.session_state.student_id = None
if "performance_data" not in st.session_state:
    st.session_state.performance_data = []
# To track if a student has taken a test before and store their details
if "student_roles" not in st.session_state:
    st.session_state.student_roles = {}  
# For adding an edge case question only once per test
if "edge_question_added" not in st.session_state:
    st.session_state.edge_question_added = False
# To store the job preference entered by the user
if "job_preference" not in st.session_state:
    st.session_state.job_preference = ""

def save_performance_data(data):
    """Save performance data to CSV format"""
    filename = f"student_performance_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    df = pd.DataFrame(data)
    return df.to_csv(index=False).encode('utf-8')

# ‚úÖ UI Header
st.title("üìñ Adaptive Learning Quiz")
st.write("Select a domain and answer **5 questions**. The AI will recommend the next module based on your performance.")

# ‚úÖ Step 1: Domain Selection, Student ID, and Job Preference Input
if not st.session_state.test_in_progress and st.session_state.selected_domain is None:
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üßë‚Äçüéì Enter Student Details:")
        # Student ID input
        student_id_input = st.text_input("Student ID:", key="student_id_input")
        # If this student has taken a test before, auto-fill the job preference
        if student_id_input and student_id_input in st.session_state.student_roles:
            stored_job_pref = st.session_state.student_roles[student_id_input].get("job_preference", "")
            job_preference_input = st.text_input("What is your job preference?", value=stored_job_pref, key="job_preference_input")
            st.info("Welcome back! Your previous job preference has been loaded.")
        else:
            job_preference_input = st.text_input("What is your job preference?", key="job_preference_input")
    
    with col2:
        st.subheader("üìö Select Your Domain:")
        available_domains = list(questions_data.keys()) if questions_data else []
        domain = st.selectbox("Choose a domain:", [""] + available_domains)
    
    if domain and student_id_input and st.button("Start Test", type="primary"):
        st.session_state.student_id = student_id_input
        st.session_state.job_preference = job_preference_input  # store job preference
        
        st.session_state.selected_domain = domain
        st.session_state.test_in_progress = True
        st.session_state.current_question = 0
        st.session_state.user_answers = {}
        st.session_state.start_time = time.time()
        st.session_state.edge_question_added = False
        
        # If the student is returning, use the previously recommended module.
        if student_id_input in st.session_state.student_roles:
            prev_module = st.session_state.student_roles[student_id_input].get("recommended_module", "Easy")
            st.session_state.domain_module_progress[domain] = prev_module
        else:
            if domain not in st.session_state.domain_module_progress:
                st.session_state.domain_module_progress[domain] = "Easy"
        st.session_state.current_module = st.session_state.domain_module_progress[domain]
        st.rerun()

# ‚úÖ Step 2: Quiz Interface
if st.session_state.selected_domain and st.session_state.test_in_progress:
    # Display timer
    if st.session_state.start_time:
        elapsed_time = int(time.time() - st.session_state.start_time)
        minutes = elapsed_time // 60
        seconds = elapsed_time % 60
        st.info(f"‚è±Ô∏è Time Elapsed: {minutes:02d}:{seconds:02d}")
    
    st.subheader(f"üìö Domain: {st.session_state.selected_domain} | Level: {st.session_state.current_module}")
    st.write(f"Student ID: {st.session_state.student_id}")
    
    try:
        domain_data = questions_data.get(st.session_state.selected_domain, {})
        current_questions = domain_data.get(st.session_state.current_module, [])[:5]
        
        # If a returning student, append an extra edge case question (if available)
        if st.session_state.student_id in st.session_state.student_roles and not st.session_state.edge_question_added:
            edge_questions = domain_data.get("Edge", [])
            if edge_questions:
                current_questions.append(edge_questions[0])
                st.session_state.edge_question_added = True
        
        if not current_questions:
            st.error(f"‚ö†Ô∏è No questions available for {st.session_state.current_module} level.")
            st.session_state.test_in_progress = False
            st.session_state.selected_domain = None
            st.rerun()
        
        if st.session_state.current_question < len(current_questions):
            question_data = current_questions[st.session_state.current_question]
            
            with st.container():
                # If this is an edge case question, label it
                if question_data.get("edge_case", False):
                    st.markdown("### ‚ö†Ô∏è Edge Case Question:")
                st.write(f"**Q{st.session_state.current_question + 1}:** {question_data['question']}")
                
                selected_answer = st.radio(
                    "Select your answer:",
                    question_data["options"],
                    key=f"q{st.session_state.current_question}",
                    index=None
                )
                
                if st.button("Submit Answer", type="primary"):
                    if selected_answer is not None:
                        st.session_state.user_answers[st.session_state.current_question] = {
                            "question": question_data["question"],
                            "selected": selected_answer,
                            "correct": question_data["answer"],
                            "is_correct": selected_answer == question_data["answer"]
                        }
                        if selected_answer == question_data["answer"]:
                            st.success("‚úÖ Correct!")
                        else:
                            st.error(f"‚ùå Incorrect. The correct answer is: {question_data['answer']}")
                        
                        if st.session_state.current_question + 1 < len(current_questions):
                            st.session_state.current_question += 1
                            st.rerun()
                        else:
                            st.session_state.show_results = True
                            st.session_state.test_in_progress = False
                            st.rerun()
    except Exception as e:
        st.error(f"‚ö†Ô∏è Error displaying questions: {str(e)}")
        st.session_state.test_in_progress = False
        st.rerun()

# ‚úÖ Step 3: Show Results
if st.session_state.show_results:
    try:
        correct_answers = sum(1 for ans in st.session_state.user_answers.values() if ans["is_correct"])
        score_percentage = (correct_answers / len(st.session_state.user_answers)) * 100
        time_spent = round((time.time() - st.session_state.start_time) / 60, 2)
        
        st.success(f"üéØ Your Score: **{score_percentage:.2f}%**")
        st.info(f"‚è±Ô∏è Time Spent: **{time_spent:.2f}** minutes")
        
        if model is not None:
            state = np.array([[score_percentage, time_spent, len(st.session_state.test_history) + 1, module_map[st.session_state.current_module]]])
            prediction = model.predict(state)
            predicted_module_index = np.argmax(prediction)
            recommended_module = reverse_module_map[predicted_module_index]
            
            # Adjustment logic based on score
            if score_percentage < 50:
                if st.session_state.current_module == "Hard":
                    recommended_module = "Medium"
                elif st.session_state.current_module == "Medium":
                    recommended_module = "Easy"
                else:
                    recommended_module = "Easy"
            elif 50 <= score_percentage <= 85:
                if st.session_state.current_module == "Easy":
                    recommended_module = "Medium"
                elif st.session_state.current_module == "Medium":
                    recommended_module = "Hard"
                else:
                    recommended_module = "Hard"
            elif score_percentage > 85:
                recommended_module = "Hard"
            
            st.session_state.domain_module_progress[st.session_state.selected_domain] = recommended_module
            st.success(f"üîÆ AI Recommended Next Module: **{recommended_module}**")
            
            # Update student record with job preference and recommended module
            st.session_state.student_roles[st.session_state.student_id] = {
                "job_preference": st.session_state.job_preference,
                "recommended_module": recommended_module
            }
            
            performance_record = {
                "Student_ID": st.session_state.student_id,
                "Previous_Score": score_percentage,
                "Time_Spent": time_spent,
                "Attempt_Count": len(st.session_state.test_history) + 1,
                "Module_Difficulty": st.session_state.current_module,
                "Next_Recommended_Module": recommended_module,
                "Job_Preference": st.session_state.job_preference
            }
            st.session_state.performance_data.append(performance_record)
        else:
            recommended_module = st.session_state.current_module
        
        test_summary = {
            "Student_ID": st.session_state.student_id,
            "Domain": st.session_state.selected_domain,
            "Score": f"{score_percentage:.2f}%",
            "Time_Spent": f"{time_spent:.2f} min",
            "Previous Module": st.session_state.current_module,
            "Next Module": recommended_module,
            "Job_Preference": st.session_state.job_preference
        }
        st.session_state.test_history.append(test_summary)
        
        st.subheader("üìä Test History")
        history_df = pd.DataFrame(st.session_state.test_history)
        st.dataframe(history_df)
        
        if st.session_state.performance_data:
            csv_data = save_performance_data(st.session_state.performance_data)
            st.download_button(
                label="üì• Download Performance Data",
                data=csv_data,
                file_name="student_performance_data.csv",
                mime="text/csv"
            )
        
        if st.button("Start New Test", type="primary"):
            st.session_state.current_module = recommended_module
            st.session_state.selected_domain = None
            st.session_state.current_question = 0
            st.session_state.user_answers = {}
            st.session_state.show_results = False
            st.session_state.start_time = None
            st.rerun()
    except Exception as e:
        st.error(f"‚ö†Ô∏è Error displaying results: {str(e)}")
**/